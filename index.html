<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui"><title>The Temporal Dead Zone</title><link rel="stylesheet" type="text/css" href="lib/css/reveal.css"><link rel="stylesheet" type="text/css" href="lib/css/zenburn.css"><link rel="stylesheet" type="text/css" href="css/dark_sole.css"><link rel="stylesheet" type="text/css" href="css/sole.css"><script src="js/bundle.js" defer></script></head><body><div class="reveal"><div hidden class="twitter">@imurchie</div><div class="slides"><section data-transition="zoom"><h1>The<br /><strong>Temporal</strong><br />Dead<br />Zone<br /></h1></section><section><h2>Isaac Murchie</h2><h3>@imurchie</h3></section><section><h2>I work at <strong>Sauce Labs</strong></h2><h3 class="fragment">I build automation tools</h3><h4 class="fragment">Particularly <strong>Appium</strong></h4></section><section><h2>We recently decided to rewrite the whole Node.JS server in <strong>ES2015</strong></h2><h3 class="fragment">And some <strong>ES7</strong></h3></section><section><h3>Along the way we got really <strong>excited</strong> about the <strong>new syntax</strong></h3><h2 class="fragment">And by <strong>we</strong> we mean <strong>I</strong></h2></section><section data-transition="zoom"><h2>So, what <em>is</em> <strong>new</strong>?</h2></section><section><h1>Block scoping</h1><h2 class="fragment">and the <strong>Temporal Dead Zone</strong></h2></section><section><h2>First things first...</h2><h3 class="fragment">What is the outcome of the following code fragment?</h3><pre class="fragment"><code data-trim contenteditable>console.log(y);
var y = 9;</code></pre><pre class="fragment"><code data-trim>undefined
</code></pre></section><section><h2>Why?</h2><h1 class="fragment"><strong>Hoisting</strong>!</h1><pre class="fragment"><code data-trim contenteditable>console.log(y);
var y = 9;</code></pre><pre class="fragment"><code data-trim contenteditable>var y;
console.log(y);
y = 9;
</code></pre></section><section><h2>Everything is function scope!</h2><h3 class="fragment">So if you want a locally-scoped variable, you need an "Immediately Invoked Function Expression"</h3><pre class="fragment"><code data-trim>(function () {
  var local = 'something';
})();
console.log(local);</code></pre><pre class="fragment"><code data-trim>ReferenceError: local is not defined
</code></pre></section><section><h1>Enter <br /><strong>block scoping</strong><br /></h1><h2>with <strong>let</strong> and <strong>const</strong></h2></section><section><h2>Returning to our code (slightly modified)...</h2><h3 class="fragment">What is the outcome of the following code fragment?</h3><pre class="fragment"><code data-trim contenteditable>console.log(y);
let y = 9;</code></pre><pre class="fragment"><code data-trim>ReferenceError: can't access lexical declaration
'y' before initialization</code></pre><h4 class="fragment">This <strong>ReferenceError</strong> <em>is</em> the <strong>Temporal Dead Zone</strong></h4></section><section><h2>Further, consider this...</h2><pre><code data-trim>var y = 99;
console.log(y);
if (true) {
  var y = 42;
  console.log(y);
}
console.log(y);</code></pre><pre class="fragment"><code data-trim>99
42
42
</code></pre></section><section><h2>Which becomes, with <strong>let</strong>...</h2><pre><code data-trim>let y = 99;
console.log(y);
if (true) {
  let y = 42;
  console.log(y);
}
console.log(y);</code></pre><pre class="fragment"><code data-trim>99
42
99
</code></pre></section><section data-background="img/dwyer.gif"></section><section><h2>One further note...</h2><h3 class="fragment">What happens with <strong>var</strong> and <strong>for</strong>?</h3><pre class="fragment"><code data-trim>for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 0);
}</code></pre><pre class="fragment"><code data-trim>2
2
2
</code></pre></section><section><h3>And with <strong>let</strong>?</h3><pre class="fragment"><code data-trim>for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, 0);
}</code></pre><pre class="fragment"><code data-trim>0
1
2
</code></pre></section><section data-background="img/dwyer.gif"></section><section><h2>So, with <strong>let</strong> (and <strong>const</strong>) we get real C-like scoping in JavaScript!</h2><h3>If you're anything like me, this is exciting news!!!!</h3><h4>(Like, four exclamation point exciting!!!!)</h4></section><section><h3>Technically speaking, <strong>hoisting</strong> still occurs, as the spec notes (§13.3.1)</h3><blockquote>The variables are created when their containing Lexical Environment is instantiated</blockquote><h3>but with the added note that they can't be used before they are initialized</h3><blockquote>but may not be accessed in any way until the variable’s LexicalBinding is evaluated</blockquote></section><section><h2>What else is there in <strong>ES2015</strong>?</h2></section><section data-transition="zoom"><h1><strong>Arrow functions</strong></h1></section><section><pre><code data-trim>fs.readFile(function (data) {
  console.log(`Doin stuffs with ${data}`);
});</code></pre><h4 class="fragment">becomes</h4><pre class="fragment"><code data-trim>fs.readFile((data) => {
  console.log(`Doin stuffs with ${data} too`);
});
</code></pre></section><section><h2>It's <strong>shorter</strong>!</h2><h3 class="fragment">But as they said...</h3><h2 class="fragment">अर्धमात्रालाघवे पुत्रोत्सवं मन्यन्ते वैयाकरणा: (परिभाषेन्दुशेखखर १२२)</h2></section><section><h2>more importantly, <br />the function lexically inherits its <strong>this</strong> reference from the surrounding scope!</h2><h3 class="fragment">No more</h3><pre class="fragment"><code data-trim>var that = this;</code></pre><h3 class="fragment">or</h3><pre class="fragment"><code data-trim>function () {
  // ...
}.bind(this);
</code></pre></section><section data-transition="zoom"><h1><strong>spread</strong>/<strong>rest</strong></h1></section><section><h3>Ever needed to use <strong>Function.apply</strong> to spread out an array into named parameters?</h3><pre class="fragment"><code data-trim>function foo (x, y, z) {
  console.log(x, y, z);
}</code></pre><pre class="fragment"><code data-trim>foo.apply(null, [1, 2, 3]);</code></pre><pre class="fragment"><code data-trim>foo(...[1, 2, 3]);</code></pre><pre class="fragment"><code data-trim>1 2 3
</code></pre></section><section><h3>As the "spread" operator, <strong>...</strong> takes an array and produces a series of individual values</h3><h4 class="fragment">For function call</h4><pre class="fragment"><code data-trim>foo (...[1, 2, 3]) => foo (1, 2, 3)</code></pre><h4 class="fragment">But also for assignment and other expressions!</h4><pre class="fragment"><code data-trim>let inner = [2, 3, 4];
let outer = [1, ...inner, 5];
console.log(outer);</code></pre><pre class="fragment"><code data-trim>Array [1, 2, 3, 4, 5]
</code></pre></section><section><h3>Ever needed to use the <strong>arguments</strong> pseudo-kinda-sometimes-an-array thingy to get a variable number of arguments in a function?</h3><pre class="fragment"><code data-trim>function foo () {
  var args = Array.prototype.slice.call(arguments);
  console.log(args);
}
foo(1, 2, 3, 4, 5);</code></pre><pre class="fragment"><code data-trim>function foo (...args) {
  console.log(args);
}
foo(1, 2, 3, 4, 5);</code></pre><pre class="fragment"><code data-trim>Array [ 1, 2, 3, 4, 5 ]
</code></pre></section><section><h3>As the "rest" operator, <strong>...</strong> takes a bunch of values and produces an array</h3><h4 class="fragment">Used in parameters of a function, either all (as above), or some of them (hence "rest")</h4><pre class="fragment"><code data-trim>function foo (first, second, ...rest) {
  console.log(first, second, rest);
}
foo(1, 2, 3, 4, 5);</code></pre><pre class="fragment"><code data-trim>1 2 Array [ 3, 4, 5 ]
</code></pre></section><section data-transition="zoom"><h1><strong>default</strong> parameter values</h1></section><section><h3>No longer do you need to have expressions to configure default values</h3><pre class="fragment"><code data-trim>function foo (first, second) {
  first = first || 42;
  second = second || 99;

  // ...
}</code></pre><pre class="fragment"><code data-trim>function foo (first = 42, second = 99) {
  // ...
}
</code></pre></section><section><h4>If you omit an argument, or pass in <strong>undefined</strong> the default will be used.</h4><h4 class="fragment"><strong>null</strong> will be coerced to a primitive and used</h4></section><section data-transition="zoom"><h1><strong>destructuring</strong></h1></section><section><h3>Simplify handling of arrays and hashes</h3><h4 class="fragment">Imagine you have a function that returns an array, and you want to assign the first two values to variables <strong>x</strong> and <strong>y</strong></h4><pre class="fragment"><code data-trim>let ret = foo(),
    x = ret[0],
    y = ret[1];</code></pre><pre class="fragment"><code data-trim>let [x, y] = foo();
</code></pre></section><section><h4>Now imagine you have a function that returns an object/hash, and you want to assign members to variables</h4><pre class="fragment"><code data-trim>let ret = foo(),
    x = ret.x,
    y = ret.y;</code></pre><pre class="fragment"><code data-trim>let {x: x, y: y} = foo();</code></pre><pre class="fragment"><code data-trim>let {x, y} = foo();
</code></pre></section><section data-transition="zoom"><h1><strong>"template literals"</strong></h1><h4>Such a dumb name that it couldn't even fit on that line.</h4></section><section><h3>Think of these like Ruby's <strong>String interpolation</strong></h3><pre class="fragment"><code data-trim>var time = Data.now();
console.log('The time is ' + time);</code></pre><h4 class="fragment">Becomes...</h4><pre class="fragment"><code data-trim>let time = Data.now();
console.log(`The time is ${time}`);
</code></pre></section><section><h3>Also think of these like Ruby's <strong>heredocs</strong></h3><h4 class="fragment">Newlines are preserved!</h4><pre class="fragment"><code data-trim>let text =
`This thought is as a death which cannot choose
But weep to have that which it fears to lose.`
</code></pre></section><section data-transition="zoom"><h1>some <strong>miscellaneous</strong> stuff I couldn't pass up</h1></section><section><h3>Computed property names in object literals</h3><pre class="fragment"><code data-trim>function foo (key, value) {
  var obj = {};
  obj[key] = value;
  return obj;
}</code></pre><pre class="fragment"><code data-trim>function foo (key, value) {
  return {
    [key]: value;
  }
}
</code></pre></section><section><h3><strong>For .. of</strong> loops</h3><h4 class="fragment">Loop over values in an array</h4><pre class="fragment"><code data-trim>let array = ['z', 'y', 'x', 'w', 'v'];
for (let letter of array) {
  console.log(letter);
}</code></pre><pre class="fragment"><code data-trim>z y x w v</code></pre><h4 class="fragment">(compare to <strong>for .. in</strong> loops, which traverse indexes)</h4></section><section><h3>Much better <strong>unicode</strong> support</h3><h4 class="fragment">Unicode in regular expressions using <strong>/u</strong></h4><h4 class="fragment">Codepoint normalization</h4><h4 class="fragment">Unicode-aware String methods</h4><h4 class="fragment">Support for full unicode standard (no more surrogate pairs for non-BMP planes!)</h4></section><section><h3>Official specification (§11.8.3) of number literals in different bases</h3><pre class="fragment"><code data-trim>let decimal     = 42,
    octal       = 0o52,
    hexadecimal = 0x2a,
    binary      = 0b101010;
</code></pre></section><section data-transition="zoom"><h2>This has just been a quick overview of some of the syntactic changes that I have come to love in programming <strong>javascript</strong></h2><h3>I'm sure there are more! Find them!</h3></section><section data-transition="zoom"><blockquote>kthxbai</blockquote></section></div></div></body></html>